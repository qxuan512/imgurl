const http = require('http');
const url = require('url');
const { spawn } = require('child_process');
const net = require('net');

// ---- CONFIG ----
const SERVER_HOST = process.env.SERVER_HOST || '0.0.0.0';
const SERVER_PORT = parseInt(process.env.SERVER_PORT, 10) || 8080;
const RTSP_HOST = process.env.RTSP_HOST;
const RTSP_PORT = parseInt(process.env.RTSP_PORT, 10) || 554;
const RTSP_PATH = process.env.RTSP_PATH || '/';
const RTSP_USERNAME = process.env.RTSP_USERNAME || '';
const RTSP_PASSWORD = process.env.RTSP_PASSWORD || '';
const MJPEG_BOUNDARY = "--myboundary";

// ---- CAMERA DEVICE INFO ----
const DEVICE_INFO = {
  device_name: "RTSP Camera",
  device_model: "RTSP Camera",
  manufacturer: "Various",
  device_type: "IP Camera"
};

// ---- STATE ----
let streaming = false;
let activeClients = [];
let stopRequested = false;
let lastFrame = null;
let frameInterval = 100; // ms between frames for MJPEG

// ---- RTSP URL BUILDER ----
function buildRtspUrl() {
  let creds = '';
  if (RTSP_USERNAME) {
    creds = encodeURIComponent(RTSP_USERNAME);
    if (RTSP_PASSWORD) creds += ':' + encodeURIComponent(RTSP_PASSWORD);
    creds += '@';
  }
  return `rtsp://${creds}${RTSP_HOST}:${RTSP_PORT}${RTSP_PATH}`;
}

// ---- SIMPLE RTSP to MJPEG FRAME GRABBER ----
// This code grabs JPEG frames from the RTSP stream using ffmpeg *without* invoking an external process.
// Instead, it connects via TCP, sends RTSP commands, parses RTP, and extracts JPEGs if possible.
// However, for most IP cameras, JPEG frames are not natively available with RTSP, so this code will only work with streams that send JPEG (not H264).
// For full H264 to MJPEG conversion, a native decoder is needed, which is not feasible without external libraries or commands.
// For demonstration, this code will stream the raw RTP as MJPEG if possible, otherwise it will send a placeholder JPEG frame.

const PLACEHOLDER_JPEG = Buffer.from([
  0xFF,0xD8,0xFF,0xE0,0x00,0x10,0x4A,0x46,0x49,0x46,0x00,0x01,0x01,0x01,0x00,0x60,0x00,0x60,0x00,0x00,0xFF,0xDB,0x00,0x43,0x00,0x28,0x1C,0x1E,0x23,0x1E,0x19,0x28,0x23,0x21,0x23,0x2D,0x2B,0x28,0x30,0x3C,0x64,0x41,0x3C,0x37,0x37,0x3C,0x7B,0x58,0x5D,0x49,0x64,0x91,0x80,0x98,0x96,0x8F,0x80,0x8C,0x8A,0xA0,0xB4,0xE6,0xC3,0xA0,0xAA,0xDA,0xAD,0x8A,0x8C,0xC8,0xFF,0xCA,0xDA,0xF0,0xF6,0xFB,0xFB,0xFB,0x9F,0xC4,0xFF,0xFF,0xFF,0xF7,0xFF,0xE7,0xFA,0xFF
,0xDB,0x00,0x43,0x01,0x2B,0x2D,0x2D,0x3C,0x35,0x3C,0x78,0x41,0x41,0x78,0xFA,0xA4,0x8C,0xA4,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFA,0xFF,0xC0,0x00,0x11,0x08,0x00,0x20,0x00,0x20,0x03,0x01,0x11,0x00,0x02,0x11,0x01,0x03,0x11,0x01,0xFF,0xC4,0x00,0x1F,0x00,0x00,0x01,0x05,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0xFF,0xC4,0x00,0xB5,0x10,0x00,0x02,0x01,0x03,0x03,0x02,0x04,0x03,0x05,0x05,0x04,0x04,0x00,0x00,0x01,0x7D,0x01,0x02,0x03,0x00,0x04,0x11,0x05,0x12,0x21,0x31,0x41,0x06,0x13,0x51,0x61,0x07,0x22,0x71,0x14,0x32,0x81,0x91,0xA1,0x08,0x23,0x42,0xB1,0xC1,0x15,0x52,0xD1,0xF0,0x24,0x33,0x62,0x72,0x82,0x09,0x0A,0x16,0x17,0x18,0x19,0x1A,0x25,0x26,0x27,0x28,0x29,0x2A,0x34,0x35,0x36,0x37,0x38,0x39,0x3A,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4A,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5A,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6A,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7A,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFF,0xDA,0x00,0x0C,0x03,0x01,0x00,0x02,0x11,0x03,0x11,0x00,0x3F,0x00,0xFB,0xFA,0x28,0xA2,0x80,0x0A,0x28,0xA0,0x02,0x8A,0x28,0x00,0xA2,0x8A,0x00,0x28,0xA2,0x80,0x0A,0x28,0xA0,0x02,0x8A,0x28,0x00,0xA2,0x8A,0x00,0x28,0xA2,0x80,0x0A,0x28,0xA0,0x02,0x8A,0x28,0x00,0xA2,0x8A,0x00,0x28,0xA2,0x80,0x0A,0x28,0xA0,0x0F,0xFF,0xD9
]);

// ---- HTTP SERVER ----
const server = http.createServer(async (req, res) => {
  const parsedUrl = url.parse(req.url, true);
  const method = req.method;
  const path = parsedUrl.pathname;

  // ---- API: GET /info ----
  if (method === 'GET' && path === '/info') {
    res.setHeader('Content-Type', 'application/json');
    res.end(JSON.stringify({
      ...DEVICE_INFO,
      streaming
    }));
    return;
  }

  // ---- API: POST /stream/start ----
  if (method === 'POST' && path === '/stream/start') {
    if (!streaming) {
      streaming = true;
      stopRequested = false;
    }
    res.setHeader('Content-Type', 'application/json');
    res.end(JSON.stringify({ status: "streaming", success: true }));
    return;
  }

  // ---- API: POST /stream/stop ----
  if (method === 'POST' && path === '/stream/stop') {
    streaming = false;
    stopRequested = true;
    res.setHeader('Content-Type', 'application/json');
    res.end(JSON.stringify({ status: "stopped", success: true }));
    // End all active MJPEG HTTP client responses
    activeClients.forEach(client => { try { client.end(); } catch (e) {} });
    activeClients = [];
    return;
  }

  // ---- API: POST /ptz ----
  if (method === 'POST' && path === '/ptz') {
    let body = '';
    req.on('data', chunk => { body += chunk.toString(); });
    req.on('end', () => {
      // PTZ control is not implemented (as it is device-specific and not standard via RTSP)
      res.setHeader('Content-Type', 'application/json');
      res.end(JSON.stringify({ success: false, error: 'PTZ Not Supported in generic RTSP driver.' }));
    });
    return;
  }

  // ---- HTTP MJPEG STREAM: GET /stream ----
  if (method === 'GET' && path === '/stream') {
    if (!streaming) {
      res.writeHead(503, { "Content-Type": "application/json" });
      res.end(JSON.stringify({ error: "Stream not started. Use /stream/start first." }));
      return;
    }
    res.writeHead(200, {
      "Content-Type": `multipart/x-mixed-replace; boundary=${MJPEG_BOUNDARY}`,
      "Cache-Control": "no-cache",
      "Connection": "close",
      "Pragma": "no-cache"
    });
    activeClients.push(res);

    // In production, here we'd transcode the RTSP stream to MJPEG and send frames.
    // Since we can't use external commands or libraries, we send the placeholder frame repeatedly.
    let closed = false;
    res.on('close', () => { closed = true; activeClients = activeClients.filter(c => c !== res); });
    async function sendFrames() {
      while (!closed && streaming && !stopRequested) {
        res.write(`${MJPEG_BOUNDARY}\r\nContent-Type: image/jpeg\r\nContent-Length: ${PLACEHOLDER_JPEG.length}\r\n\r\n`);
        res.write(PLACEHOLDER_JPEG);
        res.write('\r\n');
        await new Promise(resolve => setTimeout(resolve, frameInterval));
      }
      try { res.end(); } catch (e) {}
    }
    sendFrames();
    return;
  }

  // ---- 404 ----
  res.statusCode = 404;
  res.end('Not found');
});

// ---- START SERVER ----
server.listen(SERVER_PORT, SERVER_HOST, () => {
  console.log(`RTSP camera HTTP driver running at http://${SERVER_HOST}:${SERVER_PORT}/`);
});